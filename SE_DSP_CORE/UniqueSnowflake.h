#pragma once

#include <unordered_map>
#include <assert.h>
#include "SerializationHelper_XML.h"

#if _MSC_VER >= 1600 // Only Avail in VS2010 or later.
#include <random>
#endif

typedef std::unordered_map<int, class UniqueSnowflake*> unique_object_map_t;

class UniqueSnowflake
{
public:
	enum { NONE = -1, DEALLOCATED = -2, APPLICATION = -4 };
	UniqueSnowflake();
	virtual ~UniqueSnowflake();
	int Handle() const
	{
		assert(m_unique_handle >= 0 && "must create unique handle first");
		return m_unique_handle;
	}
	void setHandle(int p_handle);
	bool handleIsSet() const
	{
		return m_unique_handle >= 0;
	}

/*
	template< class Serializer >
	void Serialise2(Serializer& s)
	{
		s("handle", m_unique_handle);
	}
*/
	template< class Serializer >
	void SerialiseB(Archive2& ar)
	{
		Serializer s(ar.xmlElement);

		s("handle", m_unique_handle);
	}

protected:
	int m_unique_handle;
};

class UniqueSnowflakeOwner
{
public:
	UniqueSnowflakeOwner();
	void Register( UniqueSnowflake* snowflake );
	void Unregister( UniqueSnowflake* snowflake );
	void Unregister( int handle );
	void setHandleAutoGenerated(UniqueSnowflake* snowflake, bool temporaryHandle = false);
	int GenerateUniqueHandleValue(bool temporaryHandle = false);
	bool HandleInUse( UniqueSnowflake* snowflake );
	UniqueSnowflake* HandleToObject( int p_handle );
	UniqueSnowflake* HandleToObjectWithNull( int p_handle );
	void swap( unique_object_map_t& objectList);
#ifdef _DEBUG
	void debugVerify();
#endif
private:
	unique_object_map_t m_unique_objects;

#if _MSC_VER >= 1600 // Only Avail in VS2010 or later.
	std::minstd_rand random_generator;
#endif
};